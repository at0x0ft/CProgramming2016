解答
1 : 10
2 : 11

理由
 8行目の関数printfによって","直後の変数の数字を表示する。この変数は、現在"(*p)++"である。
pは配列dataのポインタ変数として宣言されているため、*pはpの指す変数の中身を表示する。
(*p)++ではインクリメント演算子が変数の後ろに付加されているため、*pをprintfで表示した後に*pに1を加える。
配列のポインタは初期状態では1番目の要素を指しているため今回の*pは10を指している
よってプログラムを実行した際に、1行目に表示される数値は"10"となる。

 また、9行目の関数printfについても同様で、この場合の変数は"*p++"である。
今回もインクリメント演算子は後置されているため、先に*pを表示する(ここでの*pは8行目printf内のインクリメントを受けて、"11"となっている)。
しかし、今回は8行目の場合とは異なり、*pはカッコで括られていないため、今回加えられるのはポインタ変数pの中に格納されている配列のアドレスである。
なお、今回のポインタ変数の型はint型であるため、1回のインクリメントで次の要素を指すアドレス、具体的には4byte先のアドレスとなる。
よってプログラム実行時に、2行目には"11"となる。

 10行目の関数printfの中の変数は"--(*p)"であるため、今回はデクリメント演算子が前置されている。
今回デクリメントされている対象は*pであるため、アドレスではなくポインタ変数pの指す配列内の要素が1だけ少なくなる。
この操作の後に、printfにより表示される。
よって、端末の3行目には"7"が表示される"

 最後のforループでは、まず最初に配列の要素を指す番号が一番最初の0に初期化され、最後の要素まで順に表示されるので、
上記の3段落で行った操作が保存されたまま、要素が表示される。
よって、端末の4行目には"11 7 6 4 2"と表示される。
